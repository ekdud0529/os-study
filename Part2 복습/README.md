## 김다영

### ch.4
### 멀티 프로그래밍 대신 멀티 스레드를 사용하는 이유?
> 프로세스 생성은 많은 시간과 자원이 필요하고, 프로세스 간 데이터를 공유하기 위한 IPC 기법은 구현, 관리가 힘듭니다.
> 스레드는 자동으로 그들이 속한 프로세스의 자원과 메모리를 공유하고, 생성 속도도 더 빠르기 때문에 프로세스보다 더 효율적입니다.

### 동시성과 병렬성의 차이는?

> 동시성은 싱글 프로세서 시스템에서 프로세서가 여러 개의 스레드를 번갈아가며 수행함으로써 동시에 실행되는 것처럼 보이게 하는 방식이고,
> 병렬성은 멀티코어 시스템에서 여러 개의 코어가 각 스레드를 동시에 수행하는 방식입니다.

### ch.5
### CPU 스케줄링 결정이 발생하는 상황 4가지
> 1. 한 프로세스가 running -> waiting 상태로 전환될 때
> 2. 프로세스가 running -> ready 상태로 전환될 때
> 3. 프로세스가 waiting -> ready 상태로 전환될 때
> 4. 프로세스가 종료할 때

### 스케줄링 기준은 어떻게 나요?
> CPU 이용률과 처리량을 최대화 하고, 총 처리시간, 대기 시간, 응답 시간을 최소화하도록 스케줄링 해야합니다.

### 선점형과 비선점형 스케줄링의 차이점은?
> 선점 스케줄링은 운영체제가  CPU를 강제로 다른 프로세스에게 할당하는 방식이고,
> 비선점 스케줄링은 프로세스가 스스로 다음 프로세스에게 자리를 넘겨주는 방식입니다.

### ch.6
### 데이터가 다수의 프로세스에 의해 공유될 때의 문제점은?
> 프로세스가 동시 또는 병렬로 실행될 때, 여러 프로세스가 공유하는 데이터의 무결성에 문제가 발생하는 race condition이 발생할 수 있습니다.

### 스핀락의 단점과 이를 해결하기 위한 방안은?
> 스핀락은 락을 획득할 때까지 바쁜대기를 하는데, 이는 CPU 사이클을 낭비하게 됩니다.
> 이에 대한 해결 방법으로 Mutex lock과 Semaphore가 있는데, 락이 이미 사용중일 때 대기하는 프로세스들을 대기 큐에 넣어두고, 락이 반환되었을 때 재실행을 하는 방식을 사용합니다.

### 세마포어 대신 Spinlock을 사용하는 경우는 언제인가요?
> 뮤텍스 락에선 스레드가 큐에 들어가고, 나중에 깨워주는 과정에서 context switch가 발생한다. context switch는 오버헤드가 발생하는 방법입니다.
> 따라서 context switch가 발생하는 것보다 critical section에서 작업이 더 빨리 끝난다면, 스핀락 방식을 사용하는 것이 더 효율적입니다.
> 다만, 이는 멀티 코어 환경일때만 해당합니다. 멀티 코어에서 대기하는 스레드와 락을 취득한 스레드가 서로 다른 코어에서 실행중이라면, context switch가 발생하지 않지만, 싱글 코어 환경에선 context switch가 무조건 발생하기 때문에 전혀 이점이 없습니다.

### 이진 세마포어와 뮤텍스 차이점
> 뮤텍스는 락을 걸은 스레드만이 임계영역을 나갈 때 락을 해제할 수 있다.
> 하지만 세마포어는 락을 걸지 않은 스레드도 signal을 사용해 락을 해제할 수 있다.

## 조민서
# Chapter 4. 스레드와 병행성

## 스레드

### 스레드와 프로세스의 차이점은 무엇인가요.

프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.

프로세스는 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소공간을 독립적으로 할당 받는다.(code, heap, stack)
스레드는 이중에 stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유한다.

### **프로세스의 문제점은 무엇인가요?**

- 프로세스 생성에 큰 오버헤드가 있다. ( 프로세스를 생성할때 많은 시간이 소요됨0
- 프로세스 컨텍스트 스위칭의 비효율성, 오버헤드가큼
- 프로세스 사이에 통신이 어렵다는점 (IPC사용해야함)

### **스레드의 출현 목적은 무엇인가요?**

- 프로세스보다 크기가 작은 실행 단위 필요
- 프로세스의 생성 및 소멸에 따른 오버헤드 감소
- 빠른 컨텍스트 스위칭
- 프로세스들의 통신 시간, 방법 어려움 해소

### 멀티 스레드 이점에 대해 설명해 주세요.

프로세스는 IPC기법을 통해 자원을 공유 할 수 있습니다. 하지만 스레드는 자신이 속한 프로세스의 힙, 데이터, 파일 자원 등을 공유하므로 스레드끼리 문맥교환 하는것이 경제성이 좋습니다.

다중 처리기 구조에서 단일스레드 인 경우 처리기가 아무리 많더라도 한 처리기에서만 실행 되지만, 멀티 스레드 인 경우 여러 처리기에서 실행 할 수 있습니다. 그래서 사용자에게 응답이 빠릅니다.

### 데이터 병렬 실행, 태스크 병렬 실행

![A08586DE-899B-4CB7-A0C8-C84653C2047E.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d73c135a-c78b-4763-9c60-c0eac44c55f6/A08586DE-899B-4CB7-A0C8-C84653C2047E.jpeg)

### **스레드 풀은 무엇인가요?**

스레드를 요청할 때마다 새로운 스레드를 생성, 수행, 삭제를 통해 성능이 저하되는 것을 방지하기 위해 미리 스레드 풀에 여러개 스레드를 만들어두고, 요청이 오면 스레드 풀에서 할당해주는 방법

### 스레드 로컬 저장장치(**TLS (Thread local storage)) = 레드풀** 에 대해 설명해 주세요.

스레드 로컬 저장장치는 각 스레드가 자신의 스레드 로컬 변수(Thread Local Variables, TLV)를 가지는 메모리 공간을 말합니다. 이것은 멀티 스레드 환경에서 각 스레드가 자신의 데이터를 안전하게 저장하고 공유하지 않아도 되도록 하는 기술입니다.

스레드 로컬 저장소는 전역 변수와 비슷하지만, 전역 변수는 모든 스레드에서 공유되는 반면, 스레드 로컬 변수는 각 스레드에서만 사용할 수 있습니다. 이는 각 스레드에서 자신의 데이터를 안전하게 보호하면서, 다른 스레드에서는 그 데이터에 직접 접근할 수 없도록 하는 장점이 있습니다.

TLS는 C++, Java, Python 등 다양한 프로그래밍 언어에서 지원하고 있으며, 스레드 풀, 웹 서버, 클라우드 서비스 등의 다양한 분야에서 사용되고 있습니다.

### 스레드 로컬저장 장치 대신에 그냥 메모리구조에서 스택영역 쓰면 각 스레드마다 각자의 독립된 데이터를 가지는거 아니야?

네, 맞습니다. 스레드별로 각자 독립적인 스택 영역이 존재하기 때문에, 스택을 이용하여 각 스레드마다 독립된 데이터를 저장할 수 있습니다.

스레드 로컬 저장소(TLS)는 스레드마다 독립된 데이터를 저장하기 위한 또 다른 방법 중 하나로, 전역 변수와 달리 스레드 간 데이터의 공유나 동기화 문제를 해결할 수 있습니다. 

TLS를 사용하면 여러 스레드가 동시에 실행되는 멀티 스레드 환경에서도 각 스레드마다 독립적인 데이터를 안전하게 저장할 수 있습니다.

따라서, TLS를 사용하지 않고 스택 영역을 이용하여 각 스레드마다 독립된 데이터를 저장하는 것도 가능합니다. 하지만 이 경우 스택 영역의 크기가 고정되어 있기 때문에, 저장할 수 있는 데이터의 크기에 제한이 있을 수 있습니다. 또한, 스택 영역은 함수 호출 시 생성되는 임시 데이터의 저장에 사용되기 때문에, TLS보다는 약간 느릴 수 있습니다.

### 커널 모드로 전환되면 함수 실행을 커널 수준 스레드가 하는게 아니야?

트랩이 발생하면 실행 중인 스레드는 커널 모드로 전환되고, 해당 스레드가 실행 중이던 사용자 모드 함수는 커널 함수로 대체되고, 트랩 시스템 콜을 호출하면, 트랩은 커널 스레드에 의해 처리됩니다.

### 사용자 수준 스레드가 모드비트를 0으로 바꾸고 시스템콜을 호출하면 커널 수준 스레드가 시스템콜을 처리한다는거지?

네, 사용자 수준 스레드가 모드비트를 0으로 바꾸고 시스템 콜을 호출하면 커널 수준 스레드가 시스템 콜을 처리합니다.

사용자 수준 스레드는 운영체제에서 직접 관리되지 않기 때문에 시스템 콜을 직접 처리할 수 없습니다. 대신 사용자 수준 스레드는 시스템 콜을 호출하면 커널 모드로 전환되어 커널 수준 스레드가 시스템 콜을 처리합니다. 이 때 커널 수준 스레드는 사용자 수준 스레드의 컨텍스트를 저장하고, 시스템 콜이 완료되면 결과를 반환하고 사용자 수준 스레드로 다시 전환됩니다.

따라서, 사용자 수준 스레드는 시스템 콜을 호출하여 커널 수준 스레드가 시스템 콜을 처리하도록 하는 것이 일반적인 방법입니다.

## 멀티 스레드 모델

### 다대일 모델

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1ba72713-1194-45e6-825f-6378ea189e76/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1ba72713-1194-45e6-825f-6378ea189e76/Untitled.png)

하나의 스레드가 봉쇄되면 전체 프로세스가 봉쇄되기 때문에 시스템을 껐다켜야 합니다.

그리거 개발자가 원하는 만큼의 사용자 스레드를 생성하지만, 한번에 하나의 커널 스레드만 스케줄 할 수 있기 때문에 병렬 실행을 할 수 없습니다.

### 일대일 모델

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/14f7e1b1-dc3d-4102-8af2-7b90cb8145b5/Untitled.png)

하나의 스레드가 봉쇄되더라도 다른 스레드가 실행 될 수 있기 때문에 다대일 모델보다 더 많은 병렬 실행을 제공합니다. 

하지만 개발자가 너무 많은 스레드를 생성하지 않도록 주의 해야합니다. 사용자 스레드를 만들면 커널 스레드도 만들어야 하기 때문에 커널 스레드가 시스템 성능에 부담을 줄 수 있습니다.

### 다 대 다 모델

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6abc5e80-0aec-43bb-a5d8-b920b38756d9/Untitled.png)

사용자 스레드가 동기화되었을 때 커널 스레드는 다른 사용자 스레드를 스케줄 할 수 있습니다.
## 조예은
